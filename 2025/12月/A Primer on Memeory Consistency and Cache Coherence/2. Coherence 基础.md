# 2.1 基准系统模型

![[Figure2.1 Baseline system model used throughout this primer.png]]
如图 2.1 所示， 我们采用的基准系统模型，多核处理器芯片由多个单线核心组成，每个核心有自己的私有数据缓存，以及一个由最后一级缓存(last-level-cache, LLC)。每个核心的数据缓存都是用物理地址进行访问，并且采用写回(write-back) 方式

为了减少不必要的复杂性，基准模型中忽略了许多常见的特性，但这些特性不是本入门指南的大部分内容所必须， 这些内容包含 #指令缓存 #多级缓存 #多核之间共享的缓存 #虚拟寻址缓存 #TLB #coherent-DMA , 基准系统模型还忽略了多个多核芯片的可能性

# 2.2 incoherence 是如何发生的
出现 incoherence的可能性仅仅源于一个基本问题，存在多个可以访问缓存和内存的参与者，在现代系统中这些参与者是处理器核心，DMA引擎和可以读取或者写入的外部设备，通常关注作为处理器核心，但其他的参与者也可能存在

![[Table2.1 Example of incoherence.png]]
table 2.1 说明了一个 incoherence 的简单实例，在Time1 之前， A=42， 在 Time1 core C1 将 A 修改成 43但只写入了其缓存，这导致了 C2缓存中的 A 值变得陈旧， Core C2 执行一个 while 循环， 从其局部缓存中反复加载A的陈旧的值，显然这是一个 incoherence的例子.
为了防止 incoherence，系统必须实现一个 cache coherence 协议，使 Core 1 的 store 操作对 Core 2 可见。

2.3 Cache Coherence 接口
在非正式情况下, coherence 协议必须保证 writes 对所有的处理器都可见。 在本节中，我们将通过它们展示的抽象接口来更正式的理解 coherence 协议

![[Figure 2.2 The pipeline-coherence interface.png]]

consistency-agnostic coherence (一致性无关的连续性) 
- write 操作是同步的
- 实现与内存模型的解耦
- 与 coherence 协议交互的子系统可以假设它正在与一个不存在缓存的原子内存系统交互

consistency-directed coherence (一致性导向的连续性)
- write 是异步传播的，在所有处理器可见之前返回
- 允许观察过时的值
- 保证write可见的顺序

## 原子内存系统抽象的实现
- 单读多写(SWMR)不变量
	- 对于任何一个内存的位置在任何时刻要么一个核心何况读写，要么多个核心可读不可写
- 数据值不变量
	- 一个时期值的初始值必须等于前一个读写时期的最终值



**Consistency-Like Definitions of Coherence**
我们对于 coherence 的首选定义是从硬件实现的角度定义的， 它指定硬件强制的不变量，关于不同核心对于内存位置的访问权限和核心之间传递到数据值。
存在另一类从程序员的角度定义 coherence 的定义， 类似 memory Consistency model 如何指定架构上可见的 loads 和 stores 的顺序

对单个内存的所有 load 和 stores 在所有线程中都以相同的顺序可见


# 维护 Coherence 不变量
为了维护 一致性无关的连续性中的原子内存系统抽象的目标，我们要维护 coherence 不变量，绝大多数 coherence 协议， 称之为无效化(invalidate  protocols)， 都是为了维护这些不变量而设计的。

一个核心读取一个内存位置，它会向其他核心发送消息以获取该内存位置的当前值，并确保其他核心没有将该内存位置的缓存副本保持在 read-write 状态这些消息结束了任何活跃的 read-write 时期，并开始一个 read-only 时期。

一个核心想要写入一个内存位置，它会向其他核心发送消息以获取内存位置的当前值，如果它还没有有效的 read-only 缓存副本，并确保没有其他核心有以 read-only 或 read-write 状态缓存该内存位置的副本。这些消息结束任何活跃的 read-write 或 read-only 时期，并开始一个新的 read-write 时期。

## Coherence 的粒度
核心理论上可以对任何力度呈现 loads 和 stores， 通常范围为 1-64 字节
理论上可以以最精细的粒度实现 coherence, 在实践上一般保持在 缓存块的力度上，对于任何的 block， 要么有一个 writer， 要么有一些 reader。
在典型系统中，一个核心不可能写入块的第一个字节，而另一个核心正在写入该块中的另一个字节。尽管缓存块粒度很常见，而且我们在本入门书的其余部分都假设这一点，但应该知道有些协议在更细和更粗的粒度上保持 coherence。

