## 4.1 TSO/X86 的动机
在多核情况下，写缓冲区不再是单核情况下的不可见，写缓冲区会导致违反SC，但是写缓冲区是高性能的，为了不放弃高性能的写缓冲区。


考虑以下的模型
![[Table 4.1.png]]

这个假设是错误的。考虑表 4.1 中的示例代码（与上一章的表 3.3 相同）。假设多核处理器具有顺序核心，其中每个核心都有一个单入口写入缓冲区并按以下顺序执行代码。

1. 核心 C1 执行存储 S1，但在其写缓冲区中缓冲新存储的 NEW 值。
2. 同样，核心 C2 执行存储 S2 并将新存储的 NEW 值保存在其写缓冲区中。
3. 接下来，两个核心执行各自的加载 L1 和 L2，并获得旧值 0。
4. 最后，两个核心的写缓冲区使用新存储的值 NEW 更新内存。

最终结果是 (r1, r2) = (0, 0)。正如我们在上一章中看到的，这是 SC 禁止的执行结果。没有写缓冲区，硬件就是 SC，但有了写缓冲区，它就不是了，这使得写缓冲区在多核处理器中在架构上是可见的。

对可见的写入缓冲区的一种响应是关闭它们，但由于潜在的性能影响，供应商一直不愿这样做。另一种选择是使用激进的、推测性的 SC 实现，使写入缓冲区再次不可见，但这样做会增加复杂性，并且会浪费电力来检测违规和处理错误推测。

SPARC 和后来的 x86 选择的选项是放弃 SC，转而支持内存一致性模型，允许在每个核心上直接使用先进先出 (FIFO) 写入缓冲区。这个被称为 TSO 的新模型允许结果“(r1, r2) = (0, 0)”。这个模型让一些人感到惊讶，但事实证明，对于大多数编程习惯来说，它的行为就像 SC 一样，并且在所有情况下都得到了明确的定义。

## TSO/X86 的实现
TSO/x86 的实现问题与 SC 类似，只是增加了每个核心中的 FIFO writer buffer。

